<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>身为低保户还要写博客是不是搞错了什么</title>
    <url>/2021/06/29/%E8%BA%AB%E4%B8%BA%E4%BD%8E%E4%BF%9D%E6%88%B7%E8%BF%98%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%E6%98%AF%E4%B8%8D%E6%98%AF%E6%90%9E%E9%94%99%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>没有枪（指域名），没有炮（指服务器），只有一杆冲锋号（穷学生一个）。该如何搭建一个属于自己的博客？</p>
<p>个人建站明显不可能了，而又想定制外观、乱折腾的话，其实也就只剩 博客园 和 Hexo 两个选择了。</p>
<p>最终我选择了在 GitHub Pages 上搭建基于 Hexo 的静态网页博客，主要原因还是希望能多折腾，否则博客园无疑是个更好的选择。接下来本文就会详细介绍下如何使用 Hexo + Github 搭建博客的过程。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/image-20210705115752219.png" alt="image-20210705115752219"></p>
<h3 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo?"></a>什么是 <a href="https://hexo.io/zh-cn/">Hexo</a>?</h3><blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<h3 id="什么是静态网页"><a href="#什么是静态网页" class="headerlink" title="什么是静态网页"></a>什么是静态网页</h3><p>本人的理解是：静态网页并非静止不动的网页，而是指除了通过 URL 获得网页信息就没有其他方法<strong>与服务器</strong>交互的网页。</p>
<h3 id="什么是-GitHub-Pages？"><a href="#什么是-GitHub-Pages？" class="headerlink" title="什么是 GitHub Pages？"></a>什么是 <a href="https://pages.github.com/">GitHub Pages</a>？</h3><blockquote>
<p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面用于介绍和宣传自己的项目。</p>
</blockquote>
<h3 id="什么是-GitHub-Pages-Hexo"><a href="#什么是-GitHub-Pages-Hexo" class="headerlink" title="什么是 GitHub Pages + Hexo?"></a>什么是 GitHub Pages + Hexo?</h3><p>即将 Hexo 生成的静态网页部署在 GitHub Pages。我不太清楚 GitHub 官方对用户蹭服务器写博客的态度如何，但从大量采用这个方式的个人博客和 <a href="https://hexo.io/zh-cn/">Hexo</a> 官网的介绍来看，这一行为最起码是被长期默许的。整个过程如下图</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/Hexo-GitHubPages流程.png" alt="Hexo-GitHubPages流程"></p>
<ul>
<li>优点：完全免费；可自由选择主题外观；静态网页；维护稳定</li>
<li>缺点：相比动态博客，发文不够便利；Github 在国内访问日常性抽风</li>
</ul>
<h2 id="如何使用-GitHub-Pages-Hexo"><a href="#如何使用-GitHub-Pages-Hexo" class="headerlink" title="如何使用 GitHub Pages + Hexo?"></a>如何使用 GitHub Pages + Hexo?</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//nodejs.org/zh-cn">Node.js</a> ：Hexo 基于 Node.js，并使用 npm 安装 （Node.js 自带）</li>
<li><a href="https://link.zhihu.com/?target=https%3A//git-scm.com/downloads">Git</a> ：部署到 GitHub Pages 上，同时 Hexo 自身也需要 Git 来下载</li>
</ul>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ol>
<li>没有账号先注册 GitHub 账号，CMD 输入以下指令，用于设置用户名和邮箱（GitHub 账号所使用邮箱）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建并添加 SSH 密钥（为了 GitHub 服务器验证身份，从而使得 Hexo 可以自动 Push），CMD 输入以下指令 :</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>一路回车，最后在 C:\Users\用户名\.ssh 目录（要勾选显示“隐藏的项目”），用记事本打开 id_rsa.pub，并复制内容，在 GitHub 网页上的个人设置中添加 SSH keys，将之前复制的内容添加进去。</p>
<ol>
<li>最后在 CMD 内输入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>显示 “Hi xxx! You’ve successfully……” 则成功。</p>
<ol>
<li>创建一个 GitHub 仓库（public）用于发布博客。</li>
</ol>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>创建一个文件夹，该文件夹用于你日后本地原文件的存储，然后 CMD 内 cd 到该文件夹下，并输入以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli  # 安装 Hexo</span><br><span class="line">hexo init                # 初始化</span><br><span class="line">npm install              # 安装组件</span><br><span class="line">hexo g                   # 生成页面</span><br><span class="line">hexo s                   # 启动预览</span><br></pre></td></tr></table></figure>
<p>然后访问 <code>http://localhost:4000</code> ，出现 Hexo 默认初始化界面。</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/image-20210707005908359.png" alt="image-20210707005908359"></p>
<h3 id="Hexo-GitHub-Pages"><a href="#Hexo-GitHub-Pages" class="headerlink" title="Hexo + GitHub Pages"></a>Hexo + GitHub Pages</h3><p>首先安装 hexo-deployer-git，Hexo 用于部署到类GitHub网站上的插件（Gitee 也可以，似乎能解决国内访问困难的问题）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后修改全局 _config.yml 的 deploy 项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/仓库名</span><br><span class="line">  branch: main # 网上有些老教程写的 master，但是Github早就因为政治正确把默认分支的名字改名了</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以后每次要发布新文章或者修改就，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;&lt;name&gt;&quot;     # 新建文章</span><br></pre></td></tr></table></figure>
<p>然后 source 文件夹中会出现一个 \<name>.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo s                # 本地预览</span><br></pre></td></tr></table></figure>
<p>在 <code>http://localhost:4000</code> 打开预览，没有问题就可以部署了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d                # 部署</span><br></pre></td></tr></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>本博客使用的主题为 <a href="https://github.com/Fechin/hexo-theme-diaspora">hexo-theme-diaspora</a> ，具体方法参考该链接。</p>
<p>这个主题也可以说是比较小众又年久失修，俘获我的主要原因就是主页的第一眼，然而实际用起来真是哪哪哪都有问题。如果需要功能完善的主题，可以选择 <a href="http://theme-next.iissnan.com/">NexT</a> 这样用的人多的主题。</p>
<p>在这里也大胆地写一下关于这个主题的 todo-list：</p>
<ol>
<li>统计网页访问量等（当众处刑；</li>
<li>音乐音量调节功能；</li>
<li>漂浮且不会把文章挤到边上的 TOC ；</li>
<li>支持更多的 Markdown 第一方及第三方语法（目前连<strong>粗体</strong>都不支持）。</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>diaspora</tag>
      </tags>
  </entry>
  <entry>
    <title>用于改进任意风格迁移的归一化损失</title>
    <url>/2021/07/07/%E7%94%A8%E4%BA%8E%E6%94%B9%E8%BF%9B%E4%BB%BB%E6%84%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB%E7%9A%84%E5%BD%92%E4%B8%80%E5%8C%96%E6%8D%9F%E5%A4%B1/</url>
    <content><![CDATA[<p>本文为 <a href="https://arxiv.org/abs/2104.10064">Style-Aware Normalized Loss for Improving Arbitrary Style Transfer</a> 的概览导读</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="现有的任意风格迁移-Arbitrary-Style-Transfer—AST-方法："><a href="#现有的任意风格迁移-Arbitrary-Style-Transfer—AST-方法：" class="headerlink" title="现有的任意风格迁移(Arbitrary Style Transfer—AST)方法："></a>现有的任意风格迁移(Arbitrary Style Transfer—AST)方法：</h3><ol>
<li><a href="https://research.google/teams/brain/magenta/">Magenta – Google Research</a> ❓</li>
<li><a href="https://arxiv.org/pdf/1703.06868.pdf">AdaIN</a> 基于模型迭代的方法</li>
<li><a href="https://arxiv.org/abs/1808.04537">LinearTransfer</a> 通过前馈神经网络学习获得一个风格转移矩阵 learns the transformation matrix with a feed-forward network</li>
<li><a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/Park_Arbitrary_Style_Transfer_With_Style-Attentional_Networks_CVPR_2019_paper.pdf">SANet</a> 基于模型迭代的方法</li>
</ol>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>① 欠风格化（Under-Stylization）+ ② 过风格化（Over-Stylization）= 风格化不平衡 （imbalanced style transferability —— IST）</p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>训练样例中不同风格迁移难度不一</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>风格认知归一化损失</p>
<h2 id="发掘问题"><a href="#发掘问题" class="headerlink" title="发掘问题"></a>发掘问题</h2><p>本文改进的损失函数是传统的 NST (Neural Style Transfer) Loss</p>
<script type="math/tex; mode=display">
\mathcal{L} = \mathcal{L}_{c}(C,P) + \beta\mathcal{L}_{s}(S,P)\\</script><p>分为内容损失函数和风格损失函数两个部分</p>
<script type="math/tex; mode=display">
\begin{align*}
\mathcal{L}_{c}(C,P) &=  MSE(\mathcal{F}(C),\mathcal{F}(P))\\
\mathcal{L}_{s}(C,P) &=  MSE(\mathcal{G}\circ\mathcal{F}(C),\mathcal{G}\circ\mathcal{F}(P))
\end{align*}</script><p>其中 $C$ 为内容图，$S$ 为风格图，$P$ 为生成图，$\mathcal{F}$ 为 VGG 网络的特征输出，$\mathcal{G}$ 为格拉姆矩阵；即基于图像迭代的风格迁移方法最基本的损失函数，本文使用其来训练其他模型</p>
<h3 id="实验一-mathcal-L-s-分布"><a href="#实验一-mathcal-L-s-分布" class="headerlink" title="实验一 $\mathcal{L}_{s}$ 分布"></a>实验一 $\mathcal{L}_{s}$ 分布</h3><p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021-06/风格损失分布.png" alt="风格损失分布"></p>
<p>上图为针对四种模型，风格损失的分布，得到以下两点：</p>
<ol>
<li>不同模型 $\mathcal{L}_{s}$ 分布相似；</li>
<li>与直觉相反，$\mathcal{L}_{s}$ 高反而过风格化，不能反映风格化的程度。</li>
</ol>
<h3 id="实验二-mathcal-L-s-VS-人工评价"><a href="#实验二-mathcal-L-s-VS-人工评价" class="headerlink" title="实验二 $\mathcal{L}_{s}$ VS 人工评价"></a>实验二 $\mathcal{L}_{s}$ VS 人工评价</h3><p>$\mathcal{L}_{s}$ 越大，人工评价反而越好</p>
<p>如果将人工评价定义为三个等级 GOOD(-1)，OK(0)，BAD(1)，则如下表数据，人工评价和 $\mathcal{L}_{s}$ 是负相关</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021-06/风格损失vs人工评价.png" alt="风格损失vs人工评价"></p>
<h2 id="探讨原因"><a href="#探讨原因" class="headerlink" title="探讨原因"></a>探讨原因</h2><p>在以 Batch 为单位的训练中，如下式</p>
<script type="math/tex; mode=display">
\mathcal{L}_{s}^{Batch} = \sum_{k\in{1,...,B}} \frac{1}{B}\cdot \mathcal{L}_{s}(S_k,P_k)</script><p>由于不同风格的迁移难度不同（在格拉姆矩阵的评价指标下），换言之实际风格迁移效果与 $\mathcal{L}_s$ 不匹配，不同风格的 $\mathcal{L}_s$ 相差上千倍，经过平均后，大的 $\mathcal{L}_s$ 比重太大，导致只针对这些风格迭代模型，使得 $\mathcal{L}_s$ 高的风格过风格化， $\mathcal{L}_s$ 低的风格欠风格化</p>
<h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><p>原文作者使用了一个简单的归一化方法，将 $\mathcal{L}_{s}$ 除以其上界，如下式</p>
<script type="math/tex; mode=display">
\hat{\mathcal{L}}_{s}=\frac{\mathcal{L}_{s}}{sup\{\mathcal{L}_{s}\}}</script><p>其中 $sup{\mathcal{L}_{s}}$ 为 $\mathcal{L}_s$ 的上届，如下式</p>
<script type="math/tex; mode=display">
sup\{\mathcal{L}_{s}(S,P)\} =\frac{||\mathcal{G}\circ\mathcal{F}(S)||^2+||\mathcal{G}\circ\mathcal{F}(P)||^2}{N}</script><p>其依据是 $\mathcal{L}_{s}$ 和其上界的高度相关性</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/Ls和其上界的相关性.png" alt="Ls和其上界的相关性" style="zoom:67%;" /></p>
<h2 id="效果预期"><a href="#效果预期" class="headerlink" title="效果预期"></a>效果预期</h2><p>一个简单的改进，直接逆转了原本损失函数的缺陷</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021-06/改进后-风格损失分布.png" alt="改进后-风格损失分布"></p>
<p>该分布图为原本模型使用归一化风格损失输出的结果，可见大的 $\hat{\mathcal{L}}_s$ 对应欠风格化的图片，小的 $\hat{\mathcal{L}}_s$ 对应过风格化的图片，可以预见使用该函数训练模型将纠正风格化不平衡的问题，具体效果可见原论文，可以谓之立竿见影<img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021-06/改进后-风格损失vs人工评价.png" alt="改进后-风格损失vs人工评价"></p>
<p>人工评价也和 $\hat{\mathcal{L}}_{s}$ 是正相关的关系</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的创新起到了立竿见影的效果，然而究其创新可以说是普普通通，问题很明显，方法也很简单，绝对不存在什么奇思妙想或者开创之举，但效果确实如此明显，为何如今才有人提出。暂能想到的两个原因：</p>
<ol>
<li>通过格拉姆矩阵来计算风格相似度的方法，略老掉牙了，如今的研究热点早就跑到了各种对抗神经网络、判别器、生成器上了；</li>
<li>计算机视觉发展日新月异，很多细节都很粗糙，有大量明显的可优化点都被忽视了。</li>
</ol>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/image-20210707211703072.png" alt="结果"></p>
]]></content>
      <categories>
        <category>paper overview</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>style transfer</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Git</title>
    <url>/2021/07/14/Hello-Git/</url>
    <content><![CDATA[<p>本系列文章为本人学习 Git 的笔记，以供个人纪录和分享。</p>
<p>使用的教材为 <a href="http://iissnan.com/progit/">Pro Git</a> 。</p>
<h2 id="什么是版本控制？"><a href="#什么是版本控制？" class="headerlink" title="什么是版本控制？"></a>什么是版本控制？</h2><blockquote>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
</blockquote>
<p>如果有以下几种情况那么你就可能会需要它：</p>
<ol>
<li>你工作相关的文件不止一个，且互相关联。假想以下情况，你修改了文件A，同时由于相关性你也修改了文件B，当你后悔这个修改的时候，你就要将这两个文件都返回为未修改的状态，然而如何确保你不忘记修改文件B？又如何确保你能将两个文件退回到一个相同的版本？这时候你就会需要版本控制；</li>
<li>你的甲方有众多需求且易变，使得你不得不开发众多版本，为了协调好这些版本中不同和公用的部分，你也需要版本控制；</li>
<li>你工作需要团队协作，为了更好地同步工作进度，并且避免团队中个别成员的失误造成不可逆的影响，又想让每个成员都可以以完整的项目继续功能测试，那么你就需要版本控制；</li>
</ol>
<p>总而言之，版本控制系统的初衷是为了解决项目开发中的复杂性，其中包括项目自身和人员等方面；这也意味着无脑使用版本控制也并非好事，其本身也会增加复杂性。版本控制系统可以分为三大类：本地版本控制系统；集中化的版本控制系统；分布式版本控制系统。</p>
<h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p>很多人工作的文件夹中有类似“初版”、“一改”、“二改”、“改中改之最终改”等目录名，用以记录和区分各个版本。后来为了避免手动备份中不可避免的各种失误，开发了本地版本控制系统。</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/image-20210713001144270.png" alt="本地版本控制系统"></p>
<p>其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。值得注意的是该版本控制系统靠着记录每次文件的修改来保存不同版本的文件。</p>
<h3 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h3><blockquote>
<p> 为了让不同系统上的开发者协同工作，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
</blockquote>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/image-20210713002312936.png" alt="集中化的版本控制系统"></p>
<p>而数据集中也会带来风险集中的问题，主机宕机和数据丢失都会造成巨大问题，依靠员工碰巧保存的数据（图上的 Checkout ）由于没有版本记录，既无法确认其具体版本，也无法用于重建完整的版本控制系统。</p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><blockquote>
<p>于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p>
</blockquote>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/image-20210713004052781.png" alt="分布式版本控制系统"></p>
<p>在原书的语境中将这三种系统的关系视作一个不断上升的过程，本人认为不尽然。相对本地版本控制系统，后两者确实是进步；然而集中式和分布式则不是如此，分布式固然更加灵活更加可靠，但权限上只能限制开发者的提交和修改，从原理上并无法限制开发者获取项目文件，这对开源软件或许没有问题，然而对于闭源软件（没有额外的安全措施下），则增加了数据泄露的风险。并不能通过目前软件开发中 Git 使用最广泛，就认为其是万能的银弹。</p>
<h2 id="什么是-Git-？"><a href="#什么是-Git-？" class="headerlink" title="什么是 Git ？"></a>什么是 <a href="https://git-scm.com/">Git</a> ？</h2><p>Git 是一个开源的分布式版本控制系统。其诞生于 Linux 开源社区的需求中，Linux 的缔造者 Linus Torvalds 对其制定了以下目标：</p>
<ol>
<li>速度</li>
<li>简单的设计</li>
<li>对非线性开发模式的强力支持</li>
<li>完全分布式</li>
<li>有能力高效管理类似 Linux 内核一样的超大规模项目</li>
</ol>
<h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3><p>Git 使用 SHA-1 算法计算数据的校验和作为文件的指纹，不同版本的不同文件都保有其唯一的指纹。Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名，其由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">24b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure>
<p>文件索引由文件内容决定，这样子 Git 便可以轻易识别文件内容是否发生改变，并轻易确保文件的一致性。</p>
<h3 id="直接记录文件副本"><a href="#直接记录文件副本" class="headerlink" title="直接记录文件副本"></a>直接记录文件副本</h3><p>Linux 直接存储文件的快照，而不是像其他版本控制系统一样关注文件的改动，这为 Git 带来了速度和稳健性，但当一个大文件有一个小修改的时候也会整体备份一边，导致其可能有些滥用存储空间，然而如今的电脑在除极少数情况下，时间复杂度远比空间复杂度来得重要（硬盘总比 CPU 便宜）。开发者每次提交更新时候，Git 会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/18333fig0105-tn.png" alt="Git 保存每次更新时的文件快照"></p>
<blockquote>
<p>稍后在第三章讨论 Git 分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。</p>
</blockquote>
<h3 id="三个区域、三个状态"><a href="#三个区域、三个状态" class="headerlink" title="三个区域、三个状态"></a>三个区域、三个状态</h3><p>在 Git 中任何文件都只有三种状态：已提交（committed）、已修改（modified）以及已暂存（staged）。同时 Git 有三个工作区域：Git 的工作目录（working directory），暂存区域（staging area）以及本地仓库（repository）。其关系如下：</p>
<ol>
<li>在工作目录中修改某些文件，其状态变为已修改；</li>
<li>对修改后的文件进行快照，保存到暂存区域，其状态变为已暂存；</li>
<li>提交更新，将暂存区的文件快照永久转储到 Git 的本地仓库中，其状态变为以提交。</li>
</ol>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/07/18333fig0106-tn.png" alt="img"></p>
]]></content>
      <categories>
        <category>Hello Git</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵论：概述和LU分解</title>
    <url>/2021/09/23/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%A6%82%E8%BF%B0%E5%92%8CLU%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="0-矩阵论介绍"><a href="#0-矩阵论介绍" class="headerlink" title="0. 矩阵论介绍"></a>0. 矩阵论介绍</h1><p>上位数学系课程：泛函，群</p>
<p>前置课程：高数，线性代数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	一般矩阵 --&gt; 方阵 --&gt; 向量 --&gt; 数</span><br></pre></td></tr></table></figure>
<p>数是特殊的矩阵 =&gt; 矩阵没有部分数的属性（例：乘法交换律）</p>
<p>矩阵的三个层面：</p>
<ol>
<li>微观层面：数的组合</li>
<li>宏观层面：完全抽象物，符合某些运算的数学对象（上位数学系视角）</li>
<li>中间层面：向量组</li>
</ol>
<h1 id="1-线性方程组"><a href="#1-线性方程组" class="headerlink" title="1. 线性方程组"></a>1. 线性方程组</h1><h2 id="1-线性方程组解法（线性代数范围）"><a href="#1-线性方程组解法（线性代数范围）" class="headerlink" title="1. 线性方程组解法（线性代数范围）"></a>1. 线性方程组解法（线性代数范围）</h2><ol>
<li>Gauss 消元法</li>
<li>求逆矩阵<ol>
<li>Gauss 消元法</li>
<li>伴随矩阵</li>
</ol>
</li>
<li>克莱姆法则</li>
</ol>
<p>其中克莱姆法则和伴随矩阵复杂度为 O(n*n!)；Gauss消元法和求逆矩阵法则为 O(n^3)</p>
<h2 id="2-矩阵的LU分解"><a href="#2-矩阵的LU分解" class="headerlink" title="2. 矩阵的LU分解"></a>2. 矩阵的LU分解</h2><p>在此先介绍一个定义</p>
<p><strong>主元 pivot ：在矩阵消去（例如Gauss消元法）过程中，每列的要保留的非零元素，用它可以把该列其他消去。</strong></p>
<h3 id="L-D-U分解定理："><a href="#L-D-U分解定理：" class="headerlink" title="L(D)U分解定理："></a>L(D)U分解定理：</h3><p>如果方阵 A 的各阶<strong>顺序主子式</strong>，</p>
<script type="math/tex; mode=display">
\Delta_k\neq 0\ \ k=1,2...n</script><p>则存在唯一的主对角线上元素全为1的下三角矩阵（称为单位下三角元素）L 与唯一的<strong>非奇异</strong>上三角矩阵 U，使得</p>
<script type="math/tex; mode=display">
A = LU</script><p>或者存在唯一的单位下三角元素 L、单位上三角元素 D 和 对角矩阵，使得</p>
<script type="math/tex; mode=display">
A=LDU</script><p>注意，在矩阵乘法结合律和LU分解定理的基础上，LDU分解定理是显然的</p>
<h3 id="LU分解求法："><a href="#LU分解求法：" class="headerlink" title="LU分解求法："></a>LU分解求法：</h3><script type="math/tex; mode=display">
\begin{align}
&A=LU\  and\ L^{-1}L=I \\ \\
\Rightarrow & L^{-1}A = L^{-1}LU=U \\ \\
\Rightarrow & L^{-1}(A,I) = (L^{-1}A,L^{-1})=(U,L^{-1})
\end{align}</script><p>上面的证明过程表明，通过一系列行初等变换，即 $L^{-1}$ 分解为的初等矩阵，可以将增广矩阵 $(A,I)$ 转化为 $(U,L^{-1})$ ，接下来在<strong>求 $L^{-1}$ 的逆即可得到  $L$</strong> </p>
<p>⭐ 这里介绍一种简单的  $L$ 求法，每次矩阵消去之前都将主元以及其下方元素记下，最后各列除以其主元，即为 $L$</p>
<p>⭐ 思考：这里能否使用所有的三类初等变换？</p>
<p>答案：只能使用第三类初等变换，由于 $L^{-1}$ 为单位下三角矩阵，其只由第三类初等变换矩阵构成</p>
<h3 id="LU分解定理证明"><a href="#LU分解定理证明" class="headerlink" title="LU分解定理证明"></a>LU分解定理证明</h3><ol>
<li>必要性 $A=LU\Rightarrow \Delta_k\neq0$</li>
</ol>
<script type="math/tex; mode=display">
\begin{pmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{pmatrix} 
=
\begin{pmatrix}
L_{11} & 0 \\
L_{21} & L_{22}
\end{pmatrix} 
\begin{pmatrix}
U_{11} & U_{12} \\
0 & U_{22}
\end{pmatrix} 
=
\begin{pmatrix}
L_{11}U_{11} & L_{11}U_{12} \\
L_{21}U_{11} & L_{21}U_{12}+L_{22}U_{22}
\end{pmatrix}</script><script type="math/tex; mode=display">
\begin{align}
\Rightarrow det(A_{11}) &= det(L_{11}U_{11})\\ \\
&=det(L_{11})det(U_{11})\\ \\
&=1\cdot det(U_{11}) \neq 0
\end{align}</script><p>考虑到 $A_{11}$ 阶数的任意性，以上证明显然对 $A$ 的任意顺序主子式都有效</p>
<ol>
<li>充分性 $A=LU\Leftarrow \Delta_k\neq0$</li>
</ol>
<p>证明充分性可以从 LU分解求法 入手，可以观察到阻碍任意方阵 LU分解 的唯一障碍，在于主元为 0</p>
<p>而 LU分解求法 中，主元左侧的元素全为 0，而 $\Delta_k\neq0$ 和初等变换不会改变行列式的非零性，可知主元必不为 0</p>
<p>所以符合 $\Delta_k\neq0$ 条件的矩阵一定可以通过上述 LU分解求法 得到 $A=LU$</p>
<h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><p>当 $A=LU$ 时，方程 $Ax=b$ 可以写成 $L(Ux)=b$ ，令 $Ux=y$ ,则有：</p>
<script type="math/tex; mode=display">
Ly=b \ \ Ux=y</script><p>即将原本单步问题化为两步，因为矩阵 $L$ 和 $U$ 都是三角矩阵，所以求解上述两个方程比直接求解 $A=LU$ 简单，其复杂度为 O(n^2) </p>
<p>然而LU分解的复杂度为 O(n^3)，似乎LU分解并不能减少运算量，但LU分解最大的优点在于复用性，其第一步LU分解和第二步求解 $Ux=y$ ，仅与 $A$ 有关，和 $b$ 无关，这意味着不论 $b$ 如何改变，重复做多少次，其增加的复杂度都是 O(n^2)</p>
<p>当然LU分解法也不是只有好处的，一个明显的缺点为LU只适用于解所有顺序主子式都大于0的，通用性欠缺，但这也可以通过某些方法规避，将在下文介绍</p>
<h2 id="3-LU分解的几种推广"><a href="#3-LU分解的几种推广" class="headerlink" title="3. LU分解的几种推广"></a>3. LU分解的几种推广</h2><h3 id="带置换的LU分解——PLU分解"><a href="#带置换的LU分解——PLU分解" class="headerlink" title="带置换的LU分解——PLU分解"></a>带置换的LU分解——PLU分解</h3><p>如果存在置换矩阵 P、单位下三角矩阵 L 与 上三角矩阵 U，使得方阵 A 满足</p>
<script type="math/tex; mode=display">
PA = LU</script><p>则称上式为 A 的带置换 P 的 LU分解</p>
<p>具体 P 的选择方法可以使用列选主元法：在每列确定主元的时候，都选择该列主元位置及其下方<strong>绝对值最大</strong>的元素</p>
<p>这一方法有两个作用：</p>
<ol>
<li>可以解决上文所说的缺陷——LU分解只适用于解所有顺序主子式都大于0的</li>
</ol>
<p><img src="https://gitee.com/HonorWithPupil/img-bed/raw/master/Img/2021/09/列选主元法保证主元不为0.png" alt="列选主元法保证主元不为0" style="zoom:67%;" /></p>
<p>上图为LU分解求法中的某个步骤，蓝色为已经选择的主元，白色为0，绿色为供选择下一个的主元的区域</p>
<p>简单证明：若绿色全为0，则红色区域由于不为方阵，一定可以通过初等变换获得一个全为0的行，左侧又全为0，即整个矩阵通过初等变换得到一个全为0的行，与矩阵可逆矛盾，所以绿色区域一定存在一个不为0的元素，通过列选主元法得到的主元一定不为0</p>
<ol>
<li>由于保证消去时候的乘子都不超过1，抑制了数据误差的放大，提高计算稳定性</li>
</ol>
<h3 id="非可逆方阵"><a href="#非可逆方阵" class="headerlink" title="非可逆方阵"></a>非可逆方阵</h3><p>分为两种情况：</p>
<ol>
<li>不满秩（秩为 r ）方阵：方法和可逆方阵相似，只是 U 方阵对角线会有 n-r 个 0</li>
<li>长方形（m, n）矩阵：方法和可逆方阵相似，只是 L、U 不为方阵，L 为（m, min(m,n)），U 为（min(m,n), n）</li>
</ol>
<h2 id="4-Python-库中的-LU-分解"><a href="#4-Python-库中的-LU-分解" class="headerlink" title="4. Python 库中的 LU 分解"></a>4. Python 库中的 LU 分解</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> lu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵</span></span><br><span class="line">A = np.array([[<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">6</span>,<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用 PLU 分解，并允许本文中的几种推广 LU分解</span></span><br><span class="line">P,L,U = lu(A)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MatrixTheory</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
</search>
